{"version":3,"file":"intersection_controller.js","sources":["src/intersection_controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element/reactive-controller.js';\n\n/**\n * The callback function for a IntersectionController.\n */\nexport type IntersectionValueCallback = (\n  ...args: Parameters<IntersectionObserverCallback>\n) => unknown;\n\n/**\n * The config options for a IntersectionController.\n */\nexport interface IntersectionControllerConfig {\n  /**\n   * Configuration object for the IntersectionObserver.\n   */\n  config?: IntersectionObserverInit;\n  /**\n   * The element to observe. In addition to configuring the target here,\n   * the `observe` method can be called to observe additional targets. When not\n   * specified, the target defaults to the `host`. If set to `null`, no target\n   * is automatically observed. Only the configured target will be re-observed\n   * if the host connects again after unobserving via disconnection.\n   */\n  target?: Element | null;\n  /**\n   * The callback used to process detected changes into a value stored\n   * in the controller's `value` property.\n   */\n  callback?: IntersectionValueCallback;\n  /**\n   * An IntersectionObserver reports the initial intersection state\n   * when observe is called. Setting this flag to true skips processing this\n   * initial state for cases when this is unnecessary.\n   */\n  skipInitial?: boolean;\n}\n\n/**\n * IntersectionController is a ReactiveController that integrates an\n * IntersectionObserver with a ReactiveControllerHost's reactive update\n * lifecycle. This is typically a ReactiveElement or LitElement.\n * IntersectionObservers can be used to detect when a target element\n * \"intersects\" is visible inside of) another element or the viewport by\n * default, where intersect means \"visible inside of.\"\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the IntersectionObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class IntersectionController implements ReactiveController {\n  private _host: ReactiveControllerHost;\n  private _target: Element | null;\n  private _observer!: IntersectionObserver;\n  private _skipInitial = false;\n  /**\n   * Flag used to help manage calling the `callback` when observe is called\n   * and `skipInitial` is set to true. Note that unlike the other observers\n   * IntersectionObserver *does* report its initial state (e.g. whether or not\n   * there is an intersection). This flag is used to avoid handling this\n   * state if `skipInitial` is true.\n   */\n  private _unobservedUpdate = false;\n  /**\n   * The result of processing the observer's changes via the `callback`\n   * function.\n   */\n  value?: unknown;\n  /**\n   * Function that returns a value processed from the observer's changes.\n   * The result is stored in the `value` property.\n   */\n  callback: IntersectionValueCallback = () => true;\n  constructor(\n    host: ReactiveControllerHost,\n    {target, config, callback, skipInitial}: IntersectionControllerConfig\n  ) {\n    (this._host = host).addController(this);\n    // Target defaults to `host` unless explicitly `null`.\n    this._target =\n      target === null ? target : target ?? (this._host as unknown as Element);\n    this._skipInitial = skipInitial ?? this._skipInitial;\n    this.callback = callback ?? this.callback;\n    // Check browser support.\n    if (!window.IntersectionObserver) {\n      console.warn(\n        `IntersectionController error: browser does not support IntersectionObserver.`\n      );\n      return;\n    }\n    this._observer = new IntersectionObserver(\n      (entries: IntersectionObserverEntry[]) => {\n        const unobservedUpdate = this._unobservedUpdate;\n        this._unobservedUpdate = false;\n        if (this._skipInitial && unobservedUpdate) {\n          return;\n        }\n        this.handleChanges(entries);\n        this._host.requestUpdate();\n      },\n      config\n    );\n  }\n\n  /**\n   * Process the observer's changes with the controller's `callback`\n   * function to produce a result stored in the `value` property.\n   */\n  protected handleChanges(entries: IntersectionObserverEntry[]) {\n    this.value = this.callback(entries, this._observer);\n  }\n\n  hostConnected() {\n    if (this._target) {\n      this.observe(this._target);\n    }\n  }\n\n  hostDisconnected() {\n    this.disconnect();\n  }\n\n  async hostUpdated() {\n    // Eagerly deliver any changes that happened during update.\n    const pendingRecords = this._observer.takeRecords();\n    if (pendingRecords.length) {\n      this.handleChanges(pendingRecords);\n    }\n  }\n\n  /**\n   * Observe the target element. The controller's `target` is automatically\n   * observed when the host connects.\n   * @param target Element to observe\n   */\n  observe(target: Element) {\n    // Note, this will always trigger the callback since the initial\n    // intersection state is reported.\n    this._observer.observe(target);\n    this._unobservedUpdate = true;\n  }\n\n  /**\n   * Disconnects the observer. This is done automatically when the host\n   * disconnects.\n   */\n  protected disconnect() {\n    this._observer.disconnect();\n  }\n}\n"],"names":["IntersectionController","constructor","host","target","config","callback","skipInitial","this","_skipInitial","_unobservedUpdate","_host","addController","_target","window","IntersectionObserver","_observer","entries","unobservedUpdate","handleChanges","requestUpdate","console","warn","value","hostConnected","observe","hostDisconnected","disconnect","async","pendingRecords","takeRecords","length"],"mappings":"MA8DaA,EAuBXC,YACEC,GACAC,OAACA,EAAMC,OAAEA,EAAMC,SAAEA,EAAQC,YAAEA,IArBrBC,KAAYC,GAAG,EAQfD,KAAiBE,GAAG,EAU5BF,KAAAF,SAAsC,KAAM,GAKzCE,KAAKG,EAAQR,GAAMS,cAAcJ,MAElCA,KAAKK,EACQ,OAAXT,GAA2BA,QAATA,EAAoBI,KAAKG,EAC7CH,KAAKC,EAAeF,QAAAA,EAAeC,KAAKC,EACxCD,KAAKF,SAAWA,QAAAA,EAAYE,KAAKF,SAE5BQ,OAAOC,qBAMZP,KAAKQ,EAAY,IAAID,sBAClBE,IACC,MAAMC,EAAmBV,KAAKE,EAC9BF,KAAKE,GAAoB,EACrBF,KAAKC,GAAgBS,IAGzBV,KAAKW,cAAcF,GACnBT,KAAKG,EAAMS,gBAAe,GAE5Bf,GAfAgB,QAAQC,KACN,+EAgBL,CAMSH,cAAcF,GACtBT,KAAKe,MAAQf,KAAKF,SAASW,EAAST,KAAKQ,EAC1C,CAEDQ,gBACMhB,KAAKK,GACPL,KAAKiB,QAAQjB,KAAKK,EAErB,CAEDa,mBACElB,KAAKmB,YACN,CAEDC,oBAEE,MAAMC,EAAiBrB,KAAKQ,EAAUc,cAClCD,EAAeE,QACjBvB,KAAKW,cAAcU,EAEtB,CAODJ,QAAQrB,GAGNI,KAAKQ,EAAUS,QAAQrB,GACvBI,KAAKE,GAAoB,CAC1B,CAMSiB,aACRnB,KAAKQ,EAAUW,YAChB"}